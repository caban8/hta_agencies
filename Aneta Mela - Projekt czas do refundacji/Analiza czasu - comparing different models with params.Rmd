---
title: "Country comparison in terms of the time to recommendation"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 2
    toc_float: true
    theme:
      bg: "#202123"
      fg: "#B8BCC2"
      primary: "#EA80FC"
      secondary: "#00DAC6"
      base_font:
        google: Prompt
      heading_font:
        google: Proza Libre
params:
  transformation: 
    label: "Transformation of the dependent variable"
    value: none
    input: select
    choices: [none, logarithmic]
  Therapeutic_lumped: false
  Obszar_terapeutyczny: true
  Rekomendacja: true
  Drug_category: true
  Year: false
  Therapeutic_lumped__Kraj: false
  Therapeutic_lumped__Rekomendacja: false
  Kraj__Rekomendacja: false
  Kraj__Drug_category: false
  Obszar_terapeutyczny__Kraj: false
  Obszar_terapeutyczny__Rekomendacja: false
  Obszar_terapeutyczny__Drug_category: false
  Rekomendacja__Drug_category: false
  random_effects: 
    label: "Variables as random effects"
    value: "(1|ID)"
    input: select
    choices: [
    "(1|ID)", 
    "(1|Year)", 
    "(1|Kraj)",
    "(1|Year/ID)", 
    "(1 + ID | Kraj)",
    "(1 | ID) + (1 | Year) + (1 | Kraj)",
    ]
  minimum_days: 0
  maximum_days: 3000
  min_recommendations: 
    label: "Minimum number of recommendations per indication"
    value: 1
    input: slider
    step: 1
    min: 1
    max: 11
  weighted_model:
    label: "Include running models with weights"
    value: false
  weighted_var:
    label: "Variable used for varIdent weighting"
    value: Kraj
    input: select
    choices: [Kraj, Therapeutic_lumped, Rekomendacja, Drug_category]
---

# Setup

```{r setup, include=FALSE}
if (requireNamespace("thematic")) 
  thematic::thematic_rmd(font = "auto")

knitr::opts_chunk$set(out.width = "90%", dpi = 300)



pacman::p_load(rstatix, readxl, tidyverse, broom, lme4, DT, nlme, future, furrr)

df <- read_excel("d:/SPSS and statistics/Work/Zlecenia/Aneta Mela/Baza filtr na dates 2024-03-04.xlsx") 

df <- df %>% 
  select(-c(...1, ...2))




options(digits=4)

# Ustalam levels dla countries tak, żeby Poland było kategorią referencyjną
Kraj_lvls <- c(
      "Poland",
      "Australia",
      "Canada",
      "England",
      "France",
      "Germany",
      "Ireland",
      "New Zealand",
      "Norway",
      "Scotland",
      "The Netherlands",
      "Wales"  
    )

# Ustalam poziomy factors - Poland first
df <- df %>% 
  mutate(Kraj = factor(Kraj, levels = Kraj_lvls))



# Lump categories few observations to "other" and add DV transformations 
df <- df %>% 
  mutate(
    Therapeutic_lumped = fct_lump(Obszar_terapeutyczny, n = 7),
    Therapeutic_lumped = fct_relevel(Therapeutic_lumped, "Other"),
    log_days = if_else(dni_do_rekomendacji == 0, 1, dni_do_rekomendacji) %>% log(),
    Drug_category = if_else(Kategoria_lek == "Orphan", "Orphan", "Other")
    ) 


# Set up plan for parallet computing
plan(multisession) 



```


** JAK WSZYSTKO ZAUTOMATYZOWAĆ ŻEBY SPRAWDZAĆ WSZYSTKIE WARIANTY MODELI ** 

# Uwagi

Celem logarytmizacji dni do rekomendacji, liczba dni, która wynosiła zero zostala przekształcona do 1 (to dało możliwość obliczenia logarytmu).


# Methodology

-   Ważna kwestia. Teoretycznie mamy tutaj do czynienia z jakąś formą within-design. W końcu agencja to pojedynczy byt, dla którego mamy więcej niż jeden powtórzony pomiar.

**Mixed effects model**

What exactly having different intercepts for the random effect variable means? How can I make a conceptual or theoretical connection here?


**Which variables can be inclued as fixed-effects?**

Is there a theoretical justification to include criteria of benefits, like clinical benefit or cost-effectiveness, in the model?

There is definitely a theoretical basis for including therapeutic area, as the processing of drugs from different areas might be guided by different goals which could be reflected in differences of their prioritization by specific medical and govermnetal insitutions.

Whether the recommendation was positive or negative might also play a role. It should be easier to find reasons to dismiss a drug than to accept it, as rejection is often a result of not meeting just one of many criteria, while acceptance is more often associated with meeting all of them. 


# Infrastruktura


## Functions

```{r}

# Import functions for performance measures
source("Funkcje/performance functions.R")

```


## Tables

```{r}

html_table <- function(x) {
  x %>% 
    knitr::kable()
}

```



## Params - Parameters

Parameters included in order to vary the models:

-   Country as a fixed vs random effects?
    -   Something to consider in theoretical terms
-   Transformation of the dependent variable (to correct deviations from the assumptions, if necessary)
    -   Logarithmic
    -   Other?
-   Minimum value of observations per indication 
    

Should I compare the AIC (or other similar measure) between lm and lmer models? To justify using the latter?

    

Params for iterated markdown knitting:

-   Kraj as fixed vs random effects
-   Transformation vs no transformation


```{r}

# Set all forms of outcome variable
dv <- c("dni_do_rekomendacji", "log_days")

# Set the fixed effects
control_choose <- c(  
  params$Therapeutic_lumped,
  params$Obszar_terapeutyczny,
  params$Rekomendacja,
  params$Drug_category,
  params$Year,
  params$Therapeutic_lumped__Kraj,
  params$Therapeutic_lumped__Rekomendacja,
  params$Kraj__Rekomendacja,
  params$Kraj__Drug_category,
  params$Obszar_terapeutyczny__Kraj,
  params$Obszar_terapeutyczny__Rekomendacja,
  params$Obszar_terapeutyczny__Drug_category,
  params$Rekomendacja__Drug_category
  )




# Select predictors
control_pred <- c(
  "Therapeutic_lumped",
  "Obszar_terapeutyczny",
  "Rekomendacja",
  "Drug_category",
  "Year",
  "Therapeutic_lumped:Kraj",
  "Therapeutic_lumped:Rekomendacja",
  "Kraj:Rekomendacja",
  "Kraj:Drug_category",
  "Obszar_terapeutyczny:Kraj",
  "Obszar_terapeutyczny:Rekomendacja",
  "Obszar_terapeutyczny:Drug_category",
  "Rekomendacja:Drug_category"
  )[control_choose]


# Maxium size of combinations
combinations <- sum(control_choose)


# Create all formula combinations always including country as one of the fixed effects
control_pred2 <- map(1:combinations, combn, x = control_pred, simplify = F) %>% 
  unlist(recursive = F) %>% 
  map(sort) %>% 
  map(function(x) {c("Kraj", x)}) %>% 
  unique() %>% 
  map(str_c, collapse = " + ") %>% 
  unlist() 
  




# Set random effects
random_effects <- params$random_effects




# Set all combinations of model formulas
model_formulas <- expand_grid(dv, control_pred2, random_effects) %>% 
  mutate(
    mod_formula = future_pmap_chr(
      list(control_pred2, random_effects), 
      paste, 
      sep = " + "
      ),
    mod_formula = str_replace(mod_formula, "^.\\+", ""),
    formula = map2_chr(dv, mod_formula, str_c, sep = " ~ "),
    mod_formula = map(formula, as.formula),
    transformation = if_else(dv == "dni_do_rekomendacji", "none", "logarithmic")
    ) %>% 
  select(transformation, formula, mod_formula)




# Choose model types based on the selected parameters
model_formulas2 <- model_formulas %>% 
  filter(
    transformation == params$transformation
    )


# Should weighted models be evaluated?
weights_include <- params$weighted_model

```




# Data cleaning



```{r}


repeated_recommendations <- df %>% 
  count(ID, Agencja_kraj) %>% 
  filter(n != 1) %>% 
  nrow()



```

There were `r repeated_recommendations` instances of recommendations that were processed more than once for a given indication by a given country. 

From each such group of repeated recommendations only the one associaited with the smallest number of days is selected.




```{r}

# Select only one recommendation per country per indication
df <- df %>% 
  group_by(ID, Agencja_kraj) %>% 
  arrange(dni_do_rekomendacji) %>% 
  slice(1) %>% 
  ungroup()


# Remove missing data and unnecessary variables
df <- df %>% 
  drop_na(dni_do_rekomendacji, Therapeutic_lumped, Rekomendacja, ID) %>% 
  select(
    ID, Year, 
    Kraj, Therapeutic_lumped, Rekomendacja, Drug_category, Obszar_terapeutyczny,
    dni_do_rekomendacji, log_days)


# Add information about number of recommendations per indicaiton
df <- df %>% 
  group_by(ID) %>% 
  mutate(ID_recommendations = n()) %>% 
  ungroup() 


```


## Filtering options

```{r}

# 
df <- df %>%
  filter(
    dni_do_rekomendacji >= params$minimum_days, # Observations below a given number of days
    dni_do_rekomendacji <= params$maximum_days, # Observations below a given number of days
    ID_recommendations >= params$min_recommendations
    )


```



# Mixed-effects models 



```{r}
# Fit all variations of mixed-effects models
models_df <- model_formulas2 %>% 
  mutate(
    model = future_map(mod_formula, lmer, data = df),
    resids = future_map(model, residuals),
    predicted = future_map(model, predict),
    AIC = future_map_dbl(model, function(x) {AIC(logLik(x))}),
    r2_marg = future_map_dbl(model, r2_marginal),
    r2_cond = future_map_dbl(model, r2_conditional)
  ) %>% 
  arrange(desc(r2_marg)) %>% 
  slice(1:50) # Select only the first 40 models to avoid exceeding png max size


# Set up the height of plot
fig_height <- ceiling(nrow(models_df) / 3) * 2




# Unnest for plotting 
models_df_unnested <-  models_df %>% 
  unnest(cols = c(resids, predicted)) %>% 
  mutate(formula = fct_reorder(formula, desc(r2_marg)))
```


## Normality assumption


```{r fig.height=fig_height}
models_df_unnested %>% 
  ggplot(aes(sample = resids)) +
  geom_qq_line() +
  geom_qq() +
  facet_wrap(~formula, scales = "free", ncol = 3)


```


## Homoscedasticity assumption


```{r fig.height=fig_height}

models_df_unnested %>% 
  ggplot(aes(predicted, resids)) +
  geom_point() +
  facet_wrap(~formula, scales = "free", ncol = 3) +
  geom_smooth(se = F)

```


## Comparison of performance measures


```{r}
models_df %>% 
  select(formula, AIC, r2_marg, r2_cond) %>% 
  datatable()
  
```


## Models


```{r}

model_formulas2 %>% 
  select(-mod_formula) %>% 
  datatable()


```

# Correcting for outliers


```{r}



# Update models by removing outliers
models_reduced <- models_df %>% 
  mutate(
    data = future_map(model, filter_residuals, data = df),
    model = future_map2(mod_formula, data, lmer),
    resids = future_map(model, residuals),
    predicted = future_map(model, predict),
    AIC = future_map_dbl(model, function(x) {AIC(logLik(x))}),
    r2_marg = future_map_dbl(model, r2_marginal),
    r2_cond = future_map_dbl(model, r2_conditional)
  ) %>% 
  arrange(desc(r2_marg))

reduced_unnested <-  models_reduced %>% 
  unnest(cols = c(resids, predicted)) %>% 
  mutate(formula = fct_reorder(formula, desc(r2_marg)))




```




## Homoscedasticity assumption


```{r fig.height=fig_height}

reduced_unnested %>% 
  ggplot(aes(predicted, resids)) +
  geom_point() +
  facet_wrap(~formula, scales = "free", ncol = 3) +
  geom_smooth(se = F)

```


## Normality assumption


```{r fig.height=fig_height}
reduced_unnested %>% 
  ggplot(aes(sample = resids)) +
  geom_qq_line() +
  geom_qq() +
  facet_wrap(~formula, scales = "free", ncol = 3)


```


## Comparison of performances

```{r}
models_reduced %>% 
  select(formula, AIC, r2_marg, r2_cond) %>% 
  datatable()

```



# Weigthed mixed-effects models



```{r eval= weights_include }



# Set random effects
random_weighted <- str_c("~1 ", params$random_effects) %>% as.formula()

# Set weight
weight_var <- str_c("~ 1 | ", params$weighted_var) %>% as.formula()


# Fixed effects for the weighted model
weighted_pred <- map(1:3, combn, x = control_pred, simplify = F) %>% 
  unlist(recursive = F) %>% 
  map(c, params$weighted_var) %>% 
  map(unique) %>% 
  map(sort) %>% 
  unique() %>% 
  map(str_c, collapse = " + ") %>% 
  unlist() 




# Create a tibble with all combinations of dataframes, methods, weights and DV transformations
weighted_mods <- expand_grid(
  dv, weighted_pred
) %>% 
  mutate(
    formula = str_c(dv, " ~ ", weighted_pred),
    mod_formula = map(formula, as.formula),
    transformation = if_else(dv == "dni_do_rekomendacji", "none", "logarithmic")
  ) %>% 
  filter(
    transformation == params$transformation
  )







# Fit all variations of mixed-effects weighted models
weighted_mods2 <- weighted_mods %>% 
  mutate(
    model = future_map(
      mod_formula, 
      possibly(lme, quiet = TRUE, otherwise = NA),
      data = df, 
      random = random_weighted, 
      weights = varIdent(form = weight_var)
      ))

# Add performance measures
weighted_mods3 <- weighted_mods2 %>% 
  filter(!map_lgl(model, ~is.logical(.))) %>% 
  mutate(
  residuals = map(model, residuals),
  predicted = map(model, predict),
  AIC = map_dbl(model, function(x) {AIC(logLik(x))}),
  r2_marg = map_dbl(model, r2_marginal),
  r2_cond = map_dbl(model, r2_conditional)
  ) %>% 
  arrange(desc(r2_marg))
  
    
    
    
    
    
   

weighted_mods_unnested <-  weighted_mods3 %>% 
   unnest(cols = c(residuals, predicted)) %>% 
   mutate(formula = fct_reorder(formula, desc(r2_marg)))

```



## Normality assumption


```{r eval = weights_include}
weighted_mods_unnested %>% 
  ggplot(aes(sample = residuals)) +
  geom_qq_line() +
  geom_qq() +
  facet_wrap(~formula, scales = "free", ncol = 3)


```


## Homoscedasticity assumption


```{r fig.height=20, eval=weights_include}

weighted_mods_unnested %>% 
  ggplot(aes(predicted, residuals)) +
  geom_point() +
  facet_wrap(~formula, scales = "free", ncol = 3) +
  geom_smooth(se = F)

```


## Comparison of performance measures


```{r eval=weights_include}
weighted_mods3 %>% 
  select(formula, AIC, r2_marg, r2_cond) %>% 
  datatable()
  
```
