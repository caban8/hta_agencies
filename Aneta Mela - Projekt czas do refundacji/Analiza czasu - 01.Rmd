---
title: "Country comparison in terms of the time to recommendation"
output: 
  html_document:
    code_folding: hide
    toc: true
    toc_depth: 2
    toc_float: true
    theme: journal
params:
  run_boot: false
bibliography: references.bib
csl: apa.csl
---

# Setup

```{r setup, include=FALSE}
if (requireNamespace("thematic")) 
  thematic::thematic_rmd(font = "auto")

pacman::p_load(rstatix, readxl, tidyverse, lme4, modelr, DT, boot, future, furrr, emmeans)

df <- read_excel("d:/SPSS and statistics/Work/Zlecenia/Aneta Mela/Baza filtr na dates 2024-03-04.xlsx") 

df <- df %>% 
  select(-c(...1, ...2))

# Logical - evaluate bootstrapping chunks
boot_eval <- params$run_boot



```





**ROZWAŻYĆ OPCJĘ Z WYBRANIEM TYLKO TYCH WSKAZAŃ, GDZIE BYŁA JAKAŚ MINIMALNA LICZBA OCENIAJĄCYCH KRAJÓW?**

-   dodać jako parametr do automatyzacji
-   At least 2 observations?

Dodać do automyzacj z parametrami modele ważone





# Important notes

Celem logarytmizacji dni do rekomendacji, liczba dni, która wynosiła zero zostala przekształcona do 1 (to dało możliwość obliczenia logarytmu).


## General conclusions from multiple simulations

The smaller variance of the errors on the lower side of the predicted values remains regardless of

-   the minimum number of recommendations per indication
-   transformation of the dv (after which the smaller error variability shifts to the  the higher side of the predicted values) 
-   applying different forms of weights
-   removing outliers
-   adding an interaction between therapeutic area and country

This strongly suggests that there is some hidden variable that was not measured

Logarithmic transformation however together with removing of residuals corrects for the lack of normality of errors.

Interestingly, a model with drug category and therapeutic area, but without country, as fixed effects, and both ID and Year as random effects, follows a homoscedastic distribution of errors.


Why there is a smaller range of errors at the higher end of the predicter values? 
**Probably because only for few countries there are observations with high values of the dependent variable**



## Pytania do Anety

-   Jakie było kryterium usunięcia wybranych obserwacji z liczbą dni do rekomendacji?
-   W jaki sposób planujesz uzasadnić w artykule wybranie tych krótszych rekomendacji w ramach tych, gdzie dochodziło do powtórzeń?


# Methodology

-   Ważna kwestia. Teoretycznie mamy tutaj do czynienia z jakąś formą within-design. W końcu agencja to pojedynczy byt, dla którego mamy więcej niż jeden powtórzony pomiar.

**Mixed effects model**

What exactly having different intercepts for the random effect variable means? How can I make a conceptual or theoretical connection here?


**Which variables can be inclued as fixed-effects?**

Is there a theoretical justification to include criteria of benefits, like clinical benefit or cost-effectiveness, in the model?

There is definitely a theoretical basis for including therapeutic area, as the processing of drugs from different areas might be guided by different goals which could be reflected in differences of their prioritization by specific medical and govermnetal insitutions.

Whether the recommendation was positive or negative might also play a role. It should be easier to find reasons to dismiss a drug than to accept it, as rejection is often a result of not meeting just one of many criteria, while acceptance is more often associated with meeting all of them. 



### Final

All analyses were conducted using R version 4.3.2 [@RCoreTeam] through RStudio version 2023.12.1 Build 402 [@RStudio]. Data preparation and visualization were carried out using the tidyverse [@Tidyverse] package. Given the unbalanced nature of the dataset, a mixed-effects model was employed to appropriately handle the data structure, incorporating drug category, therapeutic area, and country as fixed effects, and drug indication as a random effect with random intercepts.

The response variable, number of days until recommendation, was log-transformed to mitigate right skewness and non-linearity. Outliers (n = 19) were removed based on their standardized values, specifically those exceeding |3| in the residuals, to meet the assumption of normality of the errors.

The model was fitted using the lme4 package [@lme4], and the pairwise comparisons between countries were obtained using the emmeans package [@emmeans]. The model exhibited heteroscedasticity, which was addressed by employing bootstrap BCa (bias-corrected and accelerated) with a 95% confidence level. This robust method was specifically applied to compute the confidence intervals for the pairwise comparisons between countries, as obtained using the emmeans package.


# General setup

## Plots

```{r}

fill_color <- "#FAA43A"
border_color <-  "#5DA5DA"
fill_2colors <- c( "#5DA5DA","#FAA43A")

```


## Tables

```{r}

html_table <- function(x) {
  x %>% 
    knitr::kable()
}

```


## Functions

```{r}
# Import functions for performance measures
source("Funkcje/performance functions.R")
```



# Data cleaning



```{r}

# Ustalam levels dla countries tak, żeby Poland było kategorią referencyjną
Kraj_lvls <- c(
      "Poland",
      "Australia",
      "Canada",
      "England",
      "France",
      "Germany",
      "Ireland",
      "New Zealand",
      "Norway",
      "Scotland",
      "The Netherlands",
      "Wales"  
    )

# Ustalam poziomy factors - Poland first
df <- df %>% 
  mutate(Kraj = factor(Kraj, levels = Kraj_lvls))



# Lump categories few observations to "other" and add DV transformations 
df <- df %>% 
  mutate(
    Therapeutic_lumped = fct_lump(Obszar_terapeutyczny, n = 7),
    Therapeutic_lumped = fct_relevel(Therapeutic_lumped, "Other"),
    log_days = if_else(dni_do_rekomendacji == 0, 1, dni_do_rekomendacji) %>% log(),
    Drug_category = if_else(Kategoria_lek == "Orphan", "Orphan", "Other")
    ) 




```



```{r}

df %>% 
  count(ID, Agencja_kraj) %>% 
  filter(n != 1)



```


Dla agencji, które miały więcej niż jedną rekomendację w danym wskazaniu, wybieram tę krótszą / wcześniejszą


```{r}

df <- df %>% 
  group_by(ID, Agencja_kraj) %>% 
  arrange(dni_do_rekomendacji) %>% 
  slice(1) %>% 
  ungroup()

```


## Isolate separate datasets for different purposes


```{r}

# Identify apparent distinctions
not_unique <- df %>% 
  select(ID, Wskazanie_rejestracyjne, Nazwa_substancji_czynnej, Nazwa_miedzynarodowa) %>% 
  unique() %>% 
  count(ID) %>% 
  filter(n > 1) %>% 
  pull(ID)

df %>% 
  select(ID, Wskazanie_rejestracyjne, Nazwa_substancji_czynnej, Nazwa_miedzynarodowa) %>% 
  unique() %>% 
  filter(ID %in% not_unique) %>% 
  html_table()

# Separate the dataset with indication info
indication_info <- df %>% 
  select(ID, Wskazanie_rejestracyjne, Nazwa_substancji_czynnej, Nazwa_miedzynarodowa) %>% 
  unique() %>% 
  group_by(ID) %>% 
  slice(1) %>% 
  ungroup()

# Isolate a given recommendation specific info
specific_info <- df %>% 
  select(Obserwacja_nr, ID, Data_rejestracji, Data_rekomendacji, starts_with("Is"), Biosimilar, 
         Link_do_rekomendacji, Rekomendowane_wskazanie, starts_with("Kat"), Kraj_n, 
         Kategoria_lek, Kategoria_lek_n) 


# Isolate the dataset for the analyses
df <- df %>% 
  select(
    ID, Year, 
    Kraj, Therapeutic_lumped, Rekomendacja, Drug_category, Obszar_terapeutyczny,
    dni_do_rekomendacji, log_days) 

```


Inspect the character variables' values


```{r}
df %>%
  select(!where(is.double)) %>% 
  map(table)
```




## Handle missing values


```{r}
# Remove missing values concerning the model
df <- df %>% 
  drop_na(dni_do_rekomendacji, Therapeutic_lumped, Rekomendacja, ID)

```





## Number of indications depending on the number of available observations

An important issue is what should be the minimum number of observations per indication, considering the latter as the random effect.


```{r}
# Number of recommendation for a given indication
indications_numbers <- df %>% 
  count(ID) 


# Join with the dataset
df <- left_join(df, indications_numbers)


indications_numbers %>% 
  count(n) %>% 
  set_names(c("observations", "indications")) %>% 
  html_table()
```

There are `r indications_numbers$indications[[1]]` indications with only one observation.


```{r}
# Extract a filtering vector for IDs with only one observation
ID_single <- df %>% 
  count(ID) %>% 
  filter(n == 1) %>% 
  pull(ID)


df %>% 
  filter(ID %in% ID_single) %>% 
  left_join(indication_info) %>% 
  select(Kraj, ID, dni_do_rekomendacji, Nazwa_substancji_czynnej, Wskazanie_rejestracyjne)


```


## Add number of recommendations per indications

```{r}
df <- df %>% 
  mutate(
    ID = factor(ID) # ID as representing separate indications
  )

```




# EDA


## Number of observations and indications per country

```{r}

df %>% 
  count(Kraj) %>% 
  arrange(desc(n))

```




## Summary stats for number of days to recommendations


```{r}
df %>% 
  get_summary_stats(dni_do_rekomendacji)
```


```{r}
df %>% 
  filter(dni_do_rekomendacji == 0)

```



### Summary statistics by Country


```{r}
stats_country <- df %>% 
   group_by(Kraj) %>% 
   get_summary_stats(dni_do_rekomendacji) %>% 
   mutate(mean = round(mean, 1)) %>% 
   select(-c(variable,  mad,  se, ci)) %>% 
   Cabix2::round_df(q1, q3, iqr, mean, sd, digits = 1) %>% 
  select(Kraj, n, min, max, mean, sd, q1, median, q3, iqr) %>% 
  set_names(c("Country", "N", "Min", "Max","M",  "SD", "Q1", "Me", "Q3", "IQR"))

stats_country %>% 
  html_table()
  
```


```{r include=FALSE}

library(flextable)
library(officer)


stats_country %>%  
  flextable()  %>% 
  Cabflex2::flex_general() %>% 
  italic(part = "header") %>% 
  footnote(
    value = as_paragraph(
      as_i("Min"), " - Minimum value; ",
      as_i("Max"), " - Maximum value; ",
      as_i("M"), " - Mean; ",
      as_i("SD"), " - Standard Deviation; ",
      as_i("Q1"), " - The Lower Quartile; ",
      as_i("Me"), " - Median; ",
      as_i("Q3"), " - The Higher Quartile; ",
      as_i("IQR"), " - Interquartile Range"
    ), ref_symbols = ""
  ) %>% 
  font(fontname = "Times New Roman", part = "footer") %>% 
   save_as_docx(path = str_c("Tabele/Dni do rekomendacji a kraj.docx"))


```





## Distribution of the number of days


```{r}
df %>% 
  ggplot(aes(dni_do_rekomendacji)) +
  geom_histogram()

```


```{r}
df %>% 
  ggplot(aes(dni_do_rekomendacji)) +
  geom_histogram() +
  facet_wrap(~Kraj)
```

The distribution of numbers of days for most countries is positively skewed. 



```{r}

df %>% 
  ggplot(aes(log_days)) +
  geom_histogram()

```
The log transformation significantly improves the distribution of number of days, reducing the number of outliers.


```{r}
df %>% 
  pivot_longer(cols = c(dni_do_rekomendacji, log_days)) %>% 
  ggplot(aes(value)) +
  geom_boxplot() +
  facet_wrap(~name, scales = "free")


```
For the untransformed number of days, majority of the observations fell between 0 to 1000 days. 
However, there was a substantiall number of outliers


```{r}
df %>% 
  ggplot(aes(Kraj, dni_do_rekomendacji)) +
  geom_boxplot() +
  coord_flip()
```
Most of the countries had a pretty wide distribution of days to recommendation, with the higher margin falling between 750 and 1250 days. Two expections were Germany - with a relatively very small distrubtion for most of its recommendations - and Poland - with a relatively larger spread. 


## Country comparison by median

```{r}

df_selected <- df %>% 
  select(ID, Kraj, dni_do_rekomendacji) 

recommendation_order <- df_selected %>% 
  group_by(ID) %>% 
  arrange(ID, dni_do_rekomendacji) %>% 
  mutate(recommendation_order = row_number()) %>% 
  ungroup()


```

Analiza ogólna, bez uwzględnienia liczby rekomendacji w ramach danego wskazania.

```{r}

recommendation_order %>% 
  group_by(Kraj) %>% 
  summarise(
    order_median = median(recommendation_order)
  ) %>% 
  arrange(order_median) %>% 
  html_table()



```
 
 
 
```{r}

# Extract number of recommendations per ID 
wskazanie_count <- df_selected %>% 
  count(ID)

# Obtain recommendation order based on country and available number of recommendations 
recommendation_order2 <- df_selected %>% 
  left_join(wskazanie_count) %>% 
  group_by(ID) %>% 
  arrange(ID, dni_do_rekomendacji) %>% 
  mutate(recommendation_order = row_number()) %>% 
  ungroup() %>% 
  group_by(Kraj, n) %>% 
  summarise(
    order_median = median(recommendation_order)
  ) %>% 
  arrange(n, order_median) %>% 
  filter(n >= 6) 


recommendation_order2 %>% 
  html_table()



```
 
 
## Mean and variance of number of days by country, recommendation and therapeutic area


```{r}
df %>% 
  ggplot(aes(Kraj, dni_do_rekomendacji, fill = Rekomendacja)) +
  geom_boxplot() +
  coord_flip()
```


```{r}
df %>% 
  group_by(Kraj, Rekomendacja) %>% 
  summarise(
    mean = mean(dni_do_rekomendacji)
  ) %>% 
  drop_na() %>% 
  ggplot(aes(Kraj, mean, fill = Rekomendacja)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip()

```




```{r}

df %>% 
  ggplot(aes(Therapeutic_lumped, dni_do_rekomendacji)) +
  geom_boxplot()

```



```{r}
df %>% 
  ggplot(aes(Rekomendacja, dni_do_rekomendacji)) +
  geom_boxplot()

```



```{r}

df %>% 
  ggplot(aes(Therapeutic_lumped, dni_do_rekomendacji, fill = Rekomendacja)) +
  geom_boxplot()


```


```{r}
df %>% 
  ggplot(aes(Therapeutic_lumped, dni_do_rekomendacji)) +
  geom_boxplot() +
  facet_wrap(~Kraj)

```
The boxplots reveal an interaction effect between country's agency and therapeutic area. 
In other words, the effect of therapetuic area on the number of days differ from country to country with some countries displaying moore or less uniform prioritazation regardless of the area (e.g. Germany and Wales), while some countries seem to give a higher priority to specific areas (e.g. Poland, Australia, or Canada).


```{r}

df %>% 
  group_by(Therapeutic_lumped, Kraj) %>% 
  get_summary_stats(dni_do_rekomendacji)

```

### Median number of days by country and year


```{r}
stats2 <- df %>% 
  group_by(Kraj, Year) %>% 
  get_summary_stats(dni_do_rekomendacji)
```


```{r}
stats <- df %>% 
  mutate(Year = factor(Year, labels = str_c(14:19, "'"))) %>% 
  group_by(Kraj, Year) %>% 
  summarise(
    median = median(dni_do_rekomendacji),
    q1 = quantile(dni_do_rekomendacji, probs = 0.25),
    q3 = quantile(dni_do_rekomendacji, probs = 0.75)
  ) 




stats %>% 
  ggplot(aes(Year, median)) +
  geom_line(color = fill_color, size = 1, group = 1) +
  geom_linerange(
    aes(ymin = q1, ymax = q3),
    size = 2,
    color = border_color
    ) +
  facet_wrap(~Kraj, ncol = 6) +
  geom_point(shape = 18, color = fill_color, fill = fill_color, size = 4) +
  theme_minimal() +
  ggExtra::removeGridX() +
  theme(
    #axis.text.x = element_text(angle = 90),
    text = element_text(size = 15)
    ) +
  labs(x = "", y = "Days to Recommendation")


```






# The final model analysis


## Null models


 
 
## Fit the model



!!!


Interestingly, a model with drug category and therapeutic area, but without country, as fixed effects, and both ID and Year as random effects, follows a homoscedastic distribution of errors.

Może zaproponować taki model??

!!!

```{r}

# Control the min number of recommendations per indication
df_final <- df %>% 
  filter(n >= 1) %>% 
  filter(dni_do_rekomendacji != 0)
```


```{r}

# log_days ~ Kraj + Therapeutic_lumped:Kraj + (1|Drug_category) + (1|Kraj)

# Problems with singularity
# log_days ~ Kraj + Drug_category + Kraj:Drug_category + Rekomendacja + Rekomendacja:Drug_category + Year + (1 + ID | Kraj)

# Problems with convergence
# log_days ~ Kraj + Rekomendacja + (1 + Year | Kraj)

# No problem with singularity
# log_days ~ Kraj +  Obszar_terapeutyczny + Rekomendacja + Year + (1|Kraj)



# Najlepsze
# log_days ~ Kraj + Drug_category + Kraj:Drug_category + Obszar_terapeutyczny + Rekomendacja + Year + (1|ID)
# log_days ~ Kraj + Drug_category + Obszar_terapeutyczny + Rekomendacja + (1|Kraj)
# log_days ~ Kraj + Drug_category + Obszar_terapeutyczny + (1|ID) + (1|Kraj)

# log_days ~ Kraj + Kraj:Rekomendacja + Obszar_terapeutyczny + (1|ID) + (1|Drug_category)

form <- formula(log(dni_do_rekomendacji) ~ Kraj + Drug_category + Obszar_terapeutyczny + (1|ID))



best_fit <- lmer(
  formula = form,
  data = df_final
  )



```

## Assumptions

```{r}


hist_resid(best_fit)

```


```{r}
homoscedasticity_plot(best_fit)

```


## Correct for outliers


```{r}
df_filtered <- filter_residuals(df_final, best_fit)


fit_filtered <- lmer(
  formula = form,
  data = df_filtered
  )

# Number of excluded observations
nobs(best_fit) - nobs(fit_filtered)

```
There were 19 observations excluded.


### Assumptions after filtering

```{r}


hist_resid(fit_filtered)

```


```{r}
homoscedasticity_plot(fit_filtered)

```



```{r}
# confint(fit_filtered)

summary(fit_filtered)

```

Delta method for obtaining se back to normal after log transformation
https://stats.oarc.ucla.edu/r/faq/how-can-i-estimate-the-standard-error-of-transformed-regression-parameters-in-r-using-the-delta-method/


## Country comparison post-hoc analysis

### Bootstrap emmeans


```{r eval = boot_eval}
library(parallel)

# Write bootstrap function
fun_boot <- function(data, idx) {
    
    # Obtain a bootstrap sample
    dat = data[idx, ]
    
    # Fit a model to the bootstrapped sample
    fit = lmer(form, data = dat)
    
    # Obtain emmeans from the model
    emm = emmeans(fit, pairwise ~ Kraj, data = dat)
    
    # Number of contrasts
    contr_n <- as_tibble(emm$contrasts) %>% nrow()
    
    # Contrasts' names
    contr_lab <- emm$contrasts %>% 
      as_tibble() %>% 
      pull(contrast) %>% 
      as.character()
    
    rtn = rep(NA, contr_n) %>% set_names(contr_lab)
    rtn[contr_lab] = predict(emm$contrasts)
    rtn
}


# Parallel execution
n_cores <- detectCores() - 1 # Leave one core free
n_bootstraps <- 2000 # Number of bootstrap samples

# Initialize cluster
cl <- makeCluster(n_cores)

# Export the dataset and the function to the cluster
clusterExport(cl, varlist = c("df_filtered", "fun_boot"))

# You might need to export the formula 'form' if it's not defined within df_filtered
# Assuming 'form' is a formula object defined in your workspace
clusterExport(cl, varlist = c("form"))

# If your function depends on packages, load them on each cluster node
clusterEvalQ(cl, library(lme4))
clusterEvalQ(cl, library(emmeans))
clusterEvalQ(cl, library(tidyverse))




# Run bootstrap with parallel computing
set.seed(123) 
boot_result <- boot(
  df_filtered, 
  fun_boot, 
  R = n_bootstraps, 
  parallel = "snow", 
  ncpus = n_cores, 
  cl = cl
  )


# Stop the cluster
stopCluster(cl)


# Export for future knitting to save on time
save(boot_result, file = "Boot results.RData")

```





```{r }

# Load exported bootstrapping results
load("Boot results.RData")



# Write iterated function for booted CI bca
boot_bca <- function(index, boot.out) {
  
  # Obtain bca ci
  bca <- boot.ci(boot.out, type = "bca", index = index)
  
  # Isolate only the values
  result <- tibble(
    comparison = names(bca$t0), 
    emmean = bca$t0,
    ci.lower = bca$bca[4], 
    ci.upper = bca$bca[5])
  
  return(result)
  
}



```


```{r eval = boot_eval}


# Extract bca 95% confidence intervals using parallel computing
plan(multisession) 

all_bca <- seq_along(boot_result$t0) %>% 
 future_map(
    boot_bca,
    boot.out = boot_result
    ) 


plan(sequential) 


# Export for future knitting to save on time
save(all_bca, file = "bca confidence intervals.Rdata")

```



```{r}

# Obtain emmeans for each country
emm <-  emmeans(fit_filtered, pairwise ~ Kraj, data = df_filtered, type = "response")

# Isolate estimated marginal means per country
emm_means <- emm$emmeans %>% 
  as_tibble() %>% 
  arrange(desc(response)) 

# Isolate levels order
Kraj_byMean <- emm_means %>% 
  pull(Kraj) %>% 
  as.character()

# Obtain emmeans for each therapeutic area
emm_obszar <- emmeans(fit_filtered, pairwise ~ Obszar_terapeutyczny, data = df_filtered, type = "response")

```





```{r}
# Load exported confidence intervals bca
load("bca confidence intervals.Rdata")

# Create a post-hoc table with information about significant results
posthoc1 <- all_bca %>% 
  reduce(add_row) %>% 
  separate(comparison, into = c("Country1", "Country2"), sep = " - ") %>% 
  mutate(across(where(is.double), ~round(., 2))) %>% 
  mutate(
    significant = if_else(
      (ci.lower > 0 & ci.upper > 0) | (ci.lower < 0 & ci.upper < 0),
      "*",
      ""
    )
  )

# Isolate a mirror posthoc table
posthoc2 <- posthoc1 %>% 
  rename(
    Country1 = Country2,
    Country2 = Country1,
    ci.lower = ci.upper,
    ci.upper = ci.lower
    ) %>% 
  mutate(across(where(is.double), ~. * -1)) 

# Combine both posthoc tables
combined_posthoc <- posthoc1 %>% 
  add_row(posthoc2) %>%
  mutate(
    across(c(Country1, Country2), ~factor(., levels = Kraj_byMean))
        ) %>% 
  mutate(est = str_c(emmean, " [", ci.lower, ", ", ci.upper, "]", significant)) %>% 
  select(Country1, Country2, est) 



# Combine both posthoc tables
combined_posthoc_table <- combined_posthoc %>% 
  arrange(Country1) %>% 
  pivot_wider(names_from = Country2, values_from = est, names_sort = T) %>% 
  rename(Country = Country1)

# Obtain sample sizes
countries_n <- boot_result$data %>% 
  count(Kraj) %>% 
  rename(Country = Kraj)

# Remove redundant values above the diagonal
combined_posthoc_table[, -1][upper.tri(combined_posthoc_table[, -1], T)] <- ""


combined_posthoc_table %>% 
  left_join(countries_n) %>% 
  mutate(Country = str_c(1:nrow(.), ". ", Country, " (n = ", n, ")")) %>% 
  select(-n) %>% 
  set_names(c("Country", 1:(ncol(.) - 1))) %>% 
  select(-ncol(.)) %>% 
  html_table() 
```

<br>

Results with an asterisk ("*") are statistically significant.


### Interpretacja

Czas od rejestracji do wydania rekomendacji w Polsce okazał się statystycznie dłuższy niż we wszystkich innych analizowanych krajach. 
Kolejnymi dwoma krajami pod względem długości postępowania rekomenadcyjnego były Irlandia i Nowa Zelandia, przy czym pomiędzy nimi nie zaobserwowano istotnej różnicy, a dla tego drugiego nie wykazano również różnicy względem Kanady i Anglii.

Kanada i Anglia charakteryzowały się podobnym czasem od rejestracji do wydania rekomendacji, który, nie licząc Holandii, był istotnie statystycznie dłuższy względem wszystkich z pozostałych, niewymienionych jeszcze krajów, tj., kolejno, Niemiec, Szkocji, Francji, Australii, Norwegii i Walii.

Na kolejnej pozycji pod względem czasu postępowania rekomenadcyjnego uplasowała się Holandia, wypadając gorzej od Francji, Australii, Norwegii i Walii. 
Nie wykazywała natomiast róznicy w czasie rekomendowania wskazań względem Niemiec i Szkocji, dla których zaobserwowano istotnie dłuższy czas wydawania rekomendacji tylko względem Walii. 

Najkrótszą liczbę dni postępowania rekomendacyjnego zaobserwowano dla, kolejno, Francji, Australii, Norwegii i Walii, które pod tym względem nie różniły się istotnie statystycznie między sobą.




Wykres dla estimated marginal means


```{r}


# Plot / line plot
emm_means %>% 
  ggplot(aes(fct_reorder(Kraj, response), response, group = 1))  +
  geom_line() +
#  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL)) +
  geom_point() +
  theme(
    axis.text.x = element_text(angle = 45)
  )

```




```{r}

emm_means %>% 
  ggplot(aes(fct_reorder(Kraj, response), response))  +
  geom_bar(stat = "identity", fill = fill_color) +
  coord_flip()

```





```{r eval=FALSE}

df_filtered %>% 
  count(Kraj)

df_filtered %>% 
  group_by(Kraj) %>% 
  summarise(mean = mean(dni_do_rekomendacji)) %>% 
  arrange(mean) %>% 
  html_table()


```



# Things to do

-   Add information about outlier observations that were removed for the final fit
    -   Update specific stats / frequencies (show two tables?)
-   Add bootstrapped means standard errors for each country with bca standard errors
    


