---
title: "Country comparison in terms of the time to recommendation"
output: 
  html_document:
    code_folding: show
    theme:
      bg: "#202123"
      fg: "#B8BCC2"
      primary: "#EA80FC"
      secondary: "#00DAC6"
      base_font:
        google: Prompt
      heading_font:
        google: Proza Libre
---

# Setup

```{r setup, include=FALSE}
if (requireNamespace("thematic")) 
  thematic::thematic_rmd(font = "auto")

pacman::p_load(rstatix, readxl, tidyverse, lme4, modelr)

df <- read_excel("d:/SPSS and statistics/Work/Zlecenia/Aneta Mela/Baza filtr na dates 2024-03-04.xlsx") 

df <- df %>% 
  select(-c(...1, ...2))





```



**ROZWAŻYĆ OPCJĘ Z WYBRANIEM TYLKO TYCH WSKAZAŃ, GDZIE BYŁA JAKAŚ MINIMALNA LICZBA OCENIAJĄCYCH KRAJÓW?**

-   dodać jako parametr do automatyzacji
-   At least 2 observations?
-   

**ROZWAŻYĆ MODEL NIE TYLKO Z RANDOM INTERCEPTS, ALE TEŻ RANDOM SLOPES**


# Uwagi

Celem logarytmizacji dni do rekomendacji, liczba dni, która wynosiła zero zostala przekształcona do 1 (to dało możliwość obliczenia logarytmu).


# Methodology

-   Ważna kwestia. Teoretycznie mamy tutaj do czynienia z jakąś formą within-design. W końcu agencja to pojedynczy byt, dla którego mamy więcej niż jeden powtórzony pomiar.

**Mixed effects model**

What exactly having different intercepts for the random effect variable means? How can I make a conceptual or theoretical connection here?


**Which variables can be inclued as fixed-effects?**

Is there a theoretical justification to include criteria of benefits, like clinical benefit or cost-effectiveness, in the model?

There is definitely a theoretical basis for including therapeutic area, as the processing of drugs from different areas might be guided by different goals which could be reflected in differences of their prioritization by specific medical and govermnetal insitutions.

Whether the recommendation was positive or negative might also play a role. It should be easier to find reasons to dismiss a drug than to accept it, as rejection is often a result of not meeting just one of many criteria, while acceptance is more often associated with meeting all of them. 


# Infrastruktura



## Tables

```{r}

html_table <- function(x) {
  x %>% 
    knitr::kable()
}

```



# Data cleaning



```{r}

# Ustalam levels dla countries tak, żeby Poland było kategorią referencyjną
Kraj_lvls <- c(
      "Poland",
      "Australia",
      "Canada",
      "England",
      "France",
      "Germany",
      "Ireland",
      "New Zealand",
      "Norway",
      "Scotland",
      "The Netherlands",
      "Wales"  
    )

# Ustalam poziomy factors - Poland first
df <- df %>% 
  mutate(Kraj = factor(Kraj, levels = Kraj_lvls))



# Lump categories few observations to "other" and add DV transformations 
df <- df %>% 
  mutate(
    Therapeutic_lumped = fct_lump(Obszar_terapeutyczny, n = 7),
    Therapeutic_lumped = fct_relevel(Therapeutic_lumped, "Other"),
    log_days = if_else(dni_do_rekomendacji == 0, 1, dni_do_rekomendacji) %>% log(),
    Drug_category = if_else(Kategoria_lek == "Orphan", "Orphan", "Other")
    ) 




```



```{r}

df %>% 
  count(ID, Agencja_kraj) %>% 
  filter(n != 1)



```


Dla agencji, które miały więcej niż jedną rekomendację w danym wskazaniu, wybieram tę krótszą / wcześniejszą


```{r}

df <- df %>% 
  group_by(ID, Agencja_kraj) %>% 
  arrange(dni_do_rekomendacji) %>% 
  slice(1) %>% 
  ungroup()

```


## Separate datasets with information about indication type and others


```{r}

# Identify apparent distinctions
not_unique <- df %>% 
  select(ID, Wskazanie_rejestracyjne, Nazwa_substancji_czynnej, Nazwa_miedzynarodowa) %>% 
  unique() %>% 
  count(ID) %>% 
  filter(n > 1) %>% 
  pull(ID)

df %>% 
  select(ID, Wskazanie_rejestracyjne, Nazwa_substancji_czynnej, Nazwa_miedzynarodowa) %>% 
  unique() %>% 
  filter(ID %in% not_unique) %>% 
  html_table()

# Separate the dataset with indication info
indication_info <- df %>% 
  select(ID, Wskazanie_rejestracyjne, Nazwa_substancji_czynnej, Nazwa_miedzynarodowa) %>% 
  unique() %>% 
  group_by(ID) %>% 
  slice(1) %>% 
  ungroup()

# Isolate a given recommendation specific info
specific_info <- df %>% 
  select(Obserwacja_nr, ID, Data_rejestracji, Data_rekomendacji, starts_with("Is"), Biosimilar, 
         Link_do_rekomendacji, Rekomendowane_wskazanie, starts_with("Kat"), Kraj_n, 
         Kategoria_lek, Kategoria_lek_n)


# Isolate the dataset for the analyses
df <- df %>% 
  select(ID, Obserwacja_nr, Therapeutic_lumped, Kraj, Rekomendacja, Year, dni_do_rekomendacji, log_days)

```


Inspect the character variables' values


```{r}
df %>%
  select(!where(is.double)) %>% 
  map(table)
```




## Handle missing values


```{r}
# Remove missing values concerning the model
df <- df %>% 
  drop_na(dni_do_rekomendacji, Therapeutic_lumped, Rekomendacja, ID)

```





## Number of indications depending on the number of available observations

An important issue is what should be the minimum number of observations per indication, considering the latter as the random effect.


```{r}
indications_numbers <- df %>% 
  count(ID) %>% 
  count(n) %>% 
  set_names(c("observations", "indications"))

indications_numbers %>% 
  html_table()
```

There are `r indications_numbers$indications[[1]]` indications with only one observation.


```{r}
# Extract a filtering vector for IDs with only one observation
ID_single <- df %>% 
  count(ID) %>% 
  filter(n == 1) %>% 
  pull(ID)


df %>% 
  filter(ID %in% ID_single) %>% 
  left_join(indication_info) %>% 
  select(Kraj, ID, dni_do_rekomendacji, Nazwa_substancji_czynnej, Wskazanie_rejestracyjne)


```






# EDA


## Number of observations and indications per country

```{r}

df %>% 
  count(Kraj) %>% 
  arrange(desc(n))

```




## Summary stats for number of days to recommendations


```{r}

df %>% 
  get_summary_stats(dni_do_rekomendacji)

df %>% 
  filter(dni_do_rekomendacji == 0)

```

## Distribution of the number of days


```{r}
df %>% 
  ggplot(aes(dni_do_rekomendacji)) +
  geom_histogram()

```


```{r}
df %>% 
  ggplot(aes(dni_do_rekomendacji)) +
  geom_histogram() +
  facet_wrap(~Kraj)
```

The distribution of numbers of days for most countries is positively skewed. 



```{r}

df %>% 
  ggplot(aes(log_days)) +
  geom_histogram()

```
The log transformation significantly improves the distribution of number of days, reducing the number of outliers.


```{r}
df %>% 
  pivot_longer(cols = c(dni_do_rekomendacji, log_days)) %>% 
  ggplot(aes(value)) +
  geom_boxplot() +
  facet_wrap(~name, scales = "free")


```
For the untransformed number of days, majority of the observations fell between 0 to 1000 days. 
However, there was a substantiall number of outliers


```{r}
df %>% 
  ggplot(aes(Kraj, dni_do_rekomendacji)) +
  geom_boxplot() +
  coord_flip()
```
Most of the countries had a pretty wide distribution of days to recommendation, with the higher margin falling between 750 and 1250 days. Two expections were Germany - with a relatively very small distrubtion for most of its recommendations - and Poland - with a relatively larger spread. 


## Country comparison by median

```{r}

df_selected <- df %>% 
  select(ID, Kraj, dni_do_rekomendacji) 

recommendation_order <- df_selected %>% 
  group_by(ID) %>% 
  arrange(ID, dni_do_rekomendacji) %>% 
  mutate(recommendation_order = row_number()) %>% 
  ungroup()


```

Analiza ogólna, bez uwzględnienia liczby rekomendacji w ramach danego wskazania.

```{r}

recommendation_order %>% 
  group_by(Kraj) %>% 
  summarise(
    order_median = median(recommendation_order)
  ) %>% 
  arrange(order_median) %>% 
  html_table()



```
 
 
 
```{r}

# Extract number of recommendations per ID 
wskazanie_count <- df_selected %>% 
  count(ID)

# Obtain recommendation order based on country and available number of recommendations 
recommendation_order2 <- df_selected %>% 
  left_join(wskazanie_count) %>% 
  group_by(ID) %>% 
  arrange(ID, dni_do_rekomendacji) %>% 
  mutate(recommendation_order = row_number()) %>% 
  ungroup() %>% 
  group_by(Kraj, n) %>% 
  summarise(
    order_median = median(recommendation_order)
  ) %>% 
  arrange(n, order_median) %>% 
  filter(n >= 6) 


recommendation_order2 %>% 
  html_table()



```
 
 
## Mean and variance of number of days by country, recommendation and therapeutic area


```{r}
df %>% 
  ggplot(aes(Kraj, dni_do_rekomendacji, fill = Rekomendacja)) +
  geom_boxplot() +
  coord_flip()
```


```{r}
df %>% 
  group_by(Kraj, Rekomendacja) %>% 
  summarise(
    mean = mean(dni_do_rekomendacji)
  ) %>% 
  drop_na() %>% 
  ggplot(aes(Kraj, mean, fill = Rekomendacja)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip()

```




```{r}

df %>% 
  ggplot(aes(Therapeutic_lumped, dni_do_rekomendacji)) +
  geom_boxplot()

```


```{r}

df %>% 
  ggplot(aes(Therapeutic_lumped, dni_do_rekomendacji, fill = Rekomendacja)) +
  geom_boxplot()


```




# Model selection


## Null model vs Only random effects model




```{r}

glm_null <- glm(log_days ~ 1, data = df)
random_null <- lmer(log_days ~ 1 + (1|ID), data = df)
random_null2 <- lmer(log_days ~ 1 + (1|Year), data = df)
random_null3 <- lmer(log_days ~ Year + (1 + Year|ID), data = df)


null_models <- tibble(
  type = c("glm", "ID as random effects", "Year as random effects", "Year and ID as random effects"),
  model = list(glm_null, random_null, random_null2, random_null3)
)


null_models %>% 
  mutate(
    AIC = map_dbl(model, AIC)
  ) %>% 
  arrange(AIC)



```



## OLS Linear model fit


```{r}



mod_lm <- lm(log_days ~ Kraj + Therapeutic_lumped + Rekomendacja, data = df)
mod_mixed <- lmer(log_days ~ Kraj + Therapeutic_lumped + Rekomendacja + (1|ID), data = df)

c(
  lm = AIC(mod_lm), mixed = AIC(mod_mixed)
)

```




## Mixed effects model - log transformed


```{r}
# Extract function for repeated modelling with updated data
model_mixed <- function(data) {
  fit <- lmer(log_days ~ Kraj + Therapeutic_lumped + Rekomendacja + (1|ID), data = data)
  
  return(fit)
}

# Import functions for performance measures
source("Funkcje/performance functions.R")


```



```{r}

# Exclude indications with only one observation
df_IDreduced <- df %>% 
  filter(!ID %in% ID_single)

# Create a list with all datasets
dataframes <- list(df, df_IDreduced)

# Set up a tibble with all datasets' versions
datasets <- tibble(
  data = dataframes,
  minimum_obs = 1:2
  )


# Obtain models
preliminary_mods <- datasets %>% 
  mutate(
    model = map(data, model_mixed),
    model_lm = map(data, lm, formula = log_days ~ Kraj + Therapeutic_lumped + Rekomendacja),
    aic_full = map_dbl(model, AIC),
    aic_lm = map_dbl(model_lm, AIC),
    summary_full = map(model, summary)
  )



preliminary_mods %>% 
  select(minimum_obs, aic_full, aic_lm) %>% 
  mutate(mixed_better = aic_full < aic_lm)

```

For both dataset versions the mixed effects model results in a better fit.


```{r}
preliminary_mods <- preliminary_mods %>% 
  select(-ends_with("lm"))

```




### Model diagnostics



```{r}

# Extract functions for quick assumptions check
hist_resid <- function(model) {
  p <- ggplot(mapping = aes(residuals(model))) +
    geom_histogram()
  print(p)
}

homoscedasticity_plot <- function(model) {
  
  p <- ggplot(mapping = aes(predict(model), residuals(model))) +
    geom_point() +
    geom_smooth(se = F)
  
  print(p)
}




```




```{r}
preliminary_mods <- preliminary_mods %>% 
  mutate(
    norm_full = map(model, hist_resid),
    homo_full = map(model, homoscedasticity_plot),
    VIF_full = map(model, car::vif)
  )
```



```{r}
cowplot::plot_grid(plotlist = preliminary_mods$norm_full )
```


The distributions of the fits to full and reduced datasets do not differ in a substantial way.


```{r}
cowplot::plot_grid(plotlist = preliminary_mods$homo_full, nrow = 2 )

```

Both models display a similar level of heteroscedasticity. 


```{r}

preliminary_mods$VIF_full


```



### Correcting models for heteroscedasticity and lack of normality 



```{r}

# Extract function for reducing 
filter_residuals <- function(data, model, cutoff = 3) {
  
  data %>% 
    mutate(resid = residuals(model) %>% scale() %>% as.double()) %>% 
    filter(abs(resid) <= cutoff)
} 




preliminary_mods <- preliminary_mods %>% 
  mutate(
    data_reduced = map2(data, model, filter_residuals),
    model_reduced = map(data_reduced, model_mixed),
    aic_reduced = map_dbl(model_reduced, AIC),
    r2_marg_reduced = map_dbl(model_reduced, r2_marginal)
  ) 
  

```




```{r}

# Add histograms and scatterplots
preliminary_mods <- preliminary_mods %>% 
  mutate(
    norm_reduced = map(model_reduced, hist_resid),
    homo_reduced = map(model_reduced, homoscedasticity_plot)
  )


# Function for adding ggplot title
add_title <- function(p, title) {
  force(title)
  p <- p +
    labs(title = title)
  print(p)
}


preliminary_plots <- preliminary_mods %>% 
  select(minimum_obs, matches("norm|homo|aic")) %>% 
  pivot_longer(-1, names_to = c(".value", "data"), names_pattern = "(.*)_(.*)") %>% 
  mutate(
    title = str_c("Data ", data, "; Min obs = ", minimum_obs, "; AIC = ", aic),
    norm = map2(norm, title, add_title ),
    homo = map2(homo, title, add_title )
  )

```

Check normality


```{r}
cowplot::plot_grid(plotlist = preliminary_plots$norm)

```


```{r}

cowplot::plot_grid(plotlist = preliminary_plots$homo)

```
Filtering the models by outliers above the absolute value of 3 of the standardized residual resulted in an improvement of heteroscedasticity.




```{r}
cowplot::plot_grid(plotlist = preliminary_plots$norm, nrow = 2)
```


Both reduced models display a normal distribution of the residuals.


```{r}

cowplot::plot_grid(plotlist = preliminary_plots$homo, nrow = 2)

```

However, both continue to have a substantial heteroscedasticity. 




#### Applying weights




```{r}
library(nlme)

# Create a vector with variables for calculating weights
weights_vars <- str_c("~ 1 | ", c("Kraj", "Therapeutic_lumped", "Rekomendacja")) 

# Create a vector with fixed effects formulas for different transformations of DVs
fixed_formulas <- str_c(c("log_days", "dni_do_rekomendacji"), " ~ Kraj + Therapeutic_lumped + Rekomendacja") 

# Create a tibble with all combinations of dataframes, methods, weights and DV transformations
weighted_mods <- expand_grid(
  DV = c("log_days", "dni_do_rekomendacji"),
  data = dataframes,
  method = c("ML", "REML"),
  weight_var = c(
    "Kraj", "Therapeutic_lumped", "Rekomendacja",
    "Kraj_Therapeutic_lumped",
    "Kraj_Rekomendacja"
    )
) %>% 
  mutate(
    across(where(is.factor), ~as.character(.)),
    observations = map_dbl(data, nrow),
    min_obs = if_else(observations == 1933, 1, 2),
    mod_details = str_c(
      "DV = ", DV, 
      "; weights = ", weight_var, 
      "; min obs per indication = ", min_obs,
      "; method = ", method
      ), # Vector for plot titles
    fixed = str_c(DV, " ~ Kraj + Therapeutic_lumped + Rekomendacja") %>% map(as.formula),
    weights = str_c("~ 1 | ", weight_var) %>% map(as.formula)
  )


```


```{r}
# Extract an lme function for iteration
lme_iterate <- function(fixed, data, method, weights) {
        lme(
          fixed = fixed,
          method = method,
          weights = varPower(value = -0.5, form =  ~fitted(.)),
          data = data, 
          random = ~ 1 | ID
        
        )
      }


# Fit all model combinations
weighted_mods2 <- weighted_mods %>% 
  mutate(
    mod = pmap(
      list(fixed, data, method, weights),
      possibly(lme_iterate, quiet = TRUE, otherwise = NA)
    )
  ) 

# Remove unfitted models
weighted_mods2 <- weighted_mods2 %>% 
  filter(!map_lgl(mod, ~is.logical(.))) %>% 
  as_tibble()
  
```




```{r}
# Obtain model performance AIC statistic
weighted_mods2 <- weighted_mods2 %>% 
  mutate(
    aic = map_dbl(mod, possibly(AIC, otherwise = Inf)),
    r2_marg = map_dbl(mod, possibly(r2_marginal, otherwise = Inf)),
    r2_cond = map_dbl(mod, possibly(r2_conditional, otherwise = Inf))
    ) %>% 
  arrange(aic)
```



```{r}
weighted_mods2 %>% 
  select(mod_details, aic, r2_marg, r2_cond) %>% 
  html_table()

```

Among the models with logarithmically transformed dependent variable, the model with countries as weight and the full dataset (that is, considering all indications, even those, which have only one observation), resulted in the best fit.

Among the models which assumed an untrasformed dependent variable, the best fit 
The best model among those where the dependent variable remained untransformed also had weights as countries, but 



```{r}

# Compare models in terms of the heteroscedasticity degree
weighted_mods2 <- weighted_mods2 %>% 
  filter(aic != Inf) %>% 
  mutate(
    homo = map(mod, homoscedasticity_plot)
  ) 


weighted_mods2$homo


```


Update the best models by removing outliers



```{r}

weighted_best <- weighted_mods2 %>% 
  arrange(desc(r2_marg)) %>% 
  slice(1:6) %>% 
  mutate(
    data_filtered = map2(data, mod, filter_residuals),
    mod_filtered = pmap(
      list(fixed, data_filtered, method, weights),
      possibly(lme_iterate, quiet = TRUE, otherwise = NA)
    )
  )

```





```{r}

weighted_best <- weighted_best %>% 
  mutate(
    homo_filtered = map(mod_filtered, homoscedasticity_plot),
    homo_filtered = map2(homo_filtered, mod_details, add_title),
    norm_filtered = map(mod_filtered, hist_resid),
    norm_filtered = map2(norm_filtered, mod_details, add_title),
  )

cowplot::plot_grid(plotlist =  weighted_best$homo_filtered)


```


```{r}
cowplot::plot_grid(plotlist =  weighted_best$norm_filtered)
```



```{r}
weighted_best %>% 
  filter(DV == "log_days") %>% 
  select(homo, homo_filtered) %>% 
  pivot_longer(everything()) %>% 
  pull(value) %>% 
  {cowplot::plot_grid(plotlist = .)}
```




```{r}


weighted_best %>% 
  filter(DV == "log_days") %>% 
  select(homo, homo_filtered) %>% 
  pivot_longer(everything()) %>% 
  pull(value) %>% 
  {cowplot::plot_grid(plotlist = .)}


```
Compare the best of the models fitted to the filtered dataset

```{r}


weighted_best <- weighted_best %>% 
  mutate(
    aic_filtered = map_dbl(mod_filtered, AIC),
    r2_marg_filtered = map_dbl(mod_filtered, r2_marginal)
  ) 


weighted_best %>% 
  select(mod_details, matches("aic|r2"))


```

As we can see adding weights to the mixed model improves the fit substantially, which can be see by an improvement in both AIC and marginal R-squared measures. 


```{r}

best_model <- weighted_best %>% 
  arrange(desc(r2_marg)) %>% 
  slice(1) 


best_model$mod_filtered

mixed_best <- lme(
  fixed = log(dni_do_rekomendacji) ~ Kraj + Therapeutic_lumped + Rekomendacja, 
  random = ~ 1 | ID,
  weights =  varIdent(form = ~1 | Kraj),
  data = best_model$data_filtered[[1]],
    method = "ML"
  
) 


```



#### Test pojedynczy

```{r}
residuals(weighted_mods2$mod[[1]]) %>% 
  scale() %>% 
  length()



mod_poj <- lme(
  fixed = log_days ~ Kraj + Therapeutic_lumped + Rekomendacja, 
  random = ~ 1 | ID,
  weights =  varIdent(form = ~1 | Kraj),
  data = filter_residuals(df_IDreduced, weighted_mods2$mod[[1]]), method = "ML"
  
) 


plot(mod_poj)
plot(preliminary_mods$model_reduced[[1]])

par(mfrow = c(1,2))
plot(predict(mod_poj), residuals(mod_poj))
plot(predict(preliminary_mods$model_reduced[[1]]), residuals(preliminary_mods$model_reduced[[1]]))
```


```{r}
lme(
  fixed = log_days ~ Kraj + Therapeutic_lumped + Rekomendacja, 
  random = ~ 1 | ID,
  weights =  varIdent(form = ~1 | Kraj),
  data = filter_residuals(df_IDreduced, weighted_mods2$mod[[1]]), method = "ML"
  
) %>% 
  homoscedasticity_plot() +
  geom_hline(yintercept = 0, color = "red")

filter_residuals(df_IDreduced, weighted_mods2$mod[[1]]) 





```



# Final model analysis



```{r}
# confint(mixed_best)
intervals(mixed_best)

```

Delta method for obtaining se back to normal after log transformation
https://stats.oarc.ucla.edu/r/faq/how-can-i-estimate-the-standard-error-of-transformed-regression-parameters-in-r-using-the-delta-method/


## Country comparison post-hoc analysis


```{r}

library(emmeans)

# Obliczam różnice dla wszystkich par krajów
emm <- emmeans(mixed_best, pairwise ~ Kraj, type = "response")





# Wyodrębniam tabelę ze średnimi dla krajów
country_means <- emm$emmeans %>% 
  as_tibble()


# Sprowadzam do macierzy ala interkorelacje
posthoc1 <- emm$contrasts %>% 
  as_tibble() %>% 
  separate(contrast, into = c("Country1", "Country2"), sep = " / ") 

posthoc2 <- posthoc1 %>% 
  rename(
    Country1 = Country2,
    Country2 = Country1
    ) 


posthoc1 %>% 
  add_row(posthoc2) %>% 
  mutate(
    across(c(Country1, Country2), ~factor(., levels = Kraj_lvls))
        ) %>% 
  mutate(sig = case_when(
    p.value > 0.05 ~ "",
    p.value <= 0.05 & p.value > 0.01 ~ "*",
    p.value <= 0.01 & p.value > 0.001 ~ "**",
    p.value <= 0.001 ~ "***"
  )) %>% 
  mutate(
    across(where(is.double), ~round(., 2))
  ) %>% 
  mutate(
    est = str_c(ratio, " (", SE, ")", sig)
  ) %>% 
  select(Country1, Country2, est) %>% 
  pivot_wider(names_from = Country2, values_from = est, names_sort = T)
```


Wykres dla estimated marginal means


```{r}

country_means %>% 
  as_tibble() %>% 
  ggplot(aes(fct_reorder(Kraj, response), response, group = 1))  +
  geom_line() +
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL)) +
  geom_point()

```




# Description and Interpretation

-   Extreme values were removed to allow for a normal distribution of the errors
-   Weights were applied based on country
-   logarithmic transformation


