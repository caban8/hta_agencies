---
title: "Country comparison in terms of the time to recommendation"
output: 
  html_document:
    code_folding: show
    theme:
      bg: "#202123"
      fg: "#B8BCC2"
      primary: "#EA80FC"
      secondary: "#00DAC6"
      base_font:
        google: Prompt
      heading_font:
        google: Proza Libre
---

# Setup

```{r setup, include=FALSE}
if (requireNamespace("thematic")) 
  thematic::thematic_rmd(font = "auto")

pacman::p_load(rstatix, readxl, tidyverse, lme4, modelr, DT)

df <- read_excel("d:/SPSS and statistics/Work/Zlecenia/Aneta Mela/Baza filtr na dates 2024-03-04.xlsx") 

df <- df %>% 
  select(-c(...1, ...2))





```





**ROZWAŻYĆ OPCJĘ Z WYBRANIEM TYLKO TYCH WSKAZAŃ, GDZIE BYŁA JAKAŚ MINIMALNA LICZBA OCENIAJĄCYCH KRAJÓW?**

-   dodać jako parametr do automatyzacji
-   At least 2 observations?

Dodać do automyzacj z parametrami modele ważone





# Important notes

Celem logarytmizacji dni do rekomendacji, liczba dni, która wynosiła zero zostala przekształcona do 1 (to dało możliwość obliczenia logarytmu).


## General conclusions from multiple simulations

The smaller variance of the errors on the lower side of the predicted values remains regardless of

-   the minimum number of recommendations per indication
-   transformation of the dv (after which the smaller error variability shifts to the  the higher side of the predicted values) 
-   applying different forms of weights
-   removing outliers
-   adding an interaction between therapeutic area and country

This strongly suggests that there is some hidden variable that was not measured

Logarithmic transformation however together with removing of residuals corrects for the lack of normality of errors.

Interestingly, a model with drug category and therapeutic area, but without country, as fixed effects, and both ID and Year as random effects, follows a homoscedastic distribution of errors.


Why there is a smaller range of errors at the higher end of the predicter values? 
**Probably because only for few countries there are observations with high values of the dependent variable**



## Pytania do Anety

-   Jakiego było kryterium usunięcia wybranych obserwacji z liczbą dni do rekomendacji?
-   W jaki sposób planujesz uzasadnić w artykule wybranie tych krótszych rekomendacji w ramach tych, gdzie dochodziło do powtórzeń?


# Methodology

-   Ważna kwestia. Teoretycznie mamy tutaj do czynienia z jakąś formą within-design. W końcu agencja to pojedynczy byt, dla którego mamy więcej niż jeden powtórzony pomiar.

**Mixed effects model**

What exactly having different intercepts for the random effect variable means? How can I make a conceptual or theoretical connection here?


**Which variables can be inclued as fixed-effects?**

Is there a theoretical justification to include criteria of benefits, like clinical benefit or cost-effectiveness, in the model?

There is definitely a theoretical basis for including therapeutic area, as the processing of drugs from different areas might be guided by different goals which could be reflected in differences of their prioritization by specific medical and govermnetal insitutions.

Whether the recommendation was positive or negative might also play a role. It should be easier to find reasons to dismiss a drug than to accept it, as rejection is often a result of not meeting just one of many criteria, while acceptance is more often associated with meeting all of them. 


# General setup



## Tables

```{r}

html_table <- function(x) {
  x %>% 
    knitr::kable()
}

```



# Data cleaning



```{r}

# Ustalam levels dla countries tak, żeby Poland było kategorią referencyjną
Kraj_lvls <- c(
      "Poland",
      "Australia",
      "Canada",
      "England",
      "France",
      "Germany",
      "Ireland",
      "New Zealand",
      "Norway",
      "Scotland",
      "The Netherlands",
      "Wales"  
    )

# Ustalam poziomy factors - Poland first
df <- df %>% 
  mutate(Kraj = factor(Kraj, levels = Kraj_lvls))



# Lump categories few observations to "other" and add DV transformations 
df <- df %>% 
  mutate(
    Therapeutic_lumped = fct_lump(Obszar_terapeutyczny, n = 7),
    Therapeutic_lumped = fct_relevel(Therapeutic_lumped, "Other"),
    log_days = if_else(dni_do_rekomendacji == 0, 1, dni_do_rekomendacji) %>% log(),
    Drug_category = if_else(Kategoria_lek == "Orphan", "Orphan", "Other")
    ) 




```



```{r}

df %>% 
  count(ID, Agencja_kraj) %>% 
  filter(n != 1)



```


Dla agencji, które miały więcej niż jedną rekomendację w danym wskazaniu, wybieram tę krótszą / wcześniejszą


```{r}

df <- df %>% 
  group_by(ID, Agencja_kraj) %>% 
  arrange(dni_do_rekomendacji) %>% 
  slice(1) %>% 
  ungroup()

```


## Separate datasets with information about indication type and others


```{r}

# Identify apparent distinctions
not_unique <- df %>% 
  select(ID, Wskazanie_rejestracyjne, Nazwa_substancji_czynnej, Nazwa_miedzynarodowa) %>% 
  unique() %>% 
  count(ID) %>% 
  filter(n > 1) %>% 
  pull(ID)

df %>% 
  select(ID, Wskazanie_rejestracyjne, Nazwa_substancji_czynnej, Nazwa_miedzynarodowa) %>% 
  unique() %>% 
  filter(ID %in% not_unique) %>% 
  html_table()

# Separate the dataset with indication info
indication_info <- df %>% 
  select(ID, Wskazanie_rejestracyjne, Nazwa_substancji_czynnej, Nazwa_miedzynarodowa) %>% 
  unique() %>% 
  group_by(ID) %>% 
  slice(1) %>% 
  ungroup()

# Isolate a given recommendation specific info
specific_info <- df %>% 
  select(Obserwacja_nr, ID, Data_rejestracji, Data_rekomendacji, starts_with("Is"), Biosimilar, 
         Link_do_rekomendacji, Rekomendowane_wskazanie, starts_with("Kat"), Kraj_n, 
         Kategoria_lek, Kategoria_lek_n)


# Isolate the dataset for the analyses
df <- df %>% 
  select(ID, Obserwacja_nr, Therapeutic_lumped, Kraj, Rekomendacja, Year, dni_do_rekomendacji, log_days)

```


Inspect the character variables' values


```{r}
df %>%
  select(!where(is.double)) %>% 
  map(table)
```




## Handle missing values


```{r}
# Remove missing values concerning the model
df <- df %>% 
  drop_na(dni_do_rekomendacji, Therapeutic_lumped, Rekomendacja, ID)

```





## Number of indications depending on the number of available observations

An important issue is what should be the minimum number of observations per indication, considering the latter as the random effect.


```{r}
indications_numbers <- df %>% 
  count(ID) %>% 
  count(n) %>% 
  set_names(c("observations", "indications"))

indications_numbers %>% 
  html_table()
```

There are `r indications_numbers$indications[[1]]` indications with only one observation.


```{r}
# Extract a filtering vector for IDs with only one observation
ID_single <- df %>% 
  count(ID) %>% 
  filter(n == 1) %>% 
  pull(ID)


df %>% 
  filter(ID %in% ID_single) %>% 
  left_join(indication_info) %>% 
  select(Kraj, ID, dni_do_rekomendacji, Nazwa_substancji_czynnej, Wskazanie_rejestracyjne)


```






# EDA


## Number of observations and indications per country

```{r}

df %>% 
  count(Kraj) %>% 
  arrange(desc(n))

```




## Summary stats for number of days to recommendations


```{r}
df %>% 
  get_summary_stats(dni_do_rekomendacji)
```


```{r}
df %>% 
  filter(dni_do_rekomendacji == 0)

```

## Distribution of the number of days


```{r}
df %>% 
  ggplot(aes(dni_do_rekomendacji)) +
  geom_histogram()

```


```{r}
df %>% 
  ggplot(aes(dni_do_rekomendacji)) +
  geom_histogram() +
  facet_wrap(~Kraj)
```

The distribution of numbers of days for most countries is positively skewed. 



```{r}

df %>% 
  ggplot(aes(log_days)) +
  geom_histogram()

```
The log transformation significantly improves the distribution of number of days, reducing the number of outliers.


```{r}
df %>% 
  pivot_longer(cols = c(dni_do_rekomendacji, log_days)) %>% 
  ggplot(aes(value)) +
  geom_boxplot() +
  facet_wrap(~name, scales = "free")


```
For the untransformed number of days, majority of the observations fell between 0 to 1000 days. 
However, there was a substantiall number of outliers


```{r}
df %>% 
  ggplot(aes(Kraj, dni_do_rekomendacji)) +
  geom_boxplot() +
  coord_flip()
```
Most of the countries had a pretty wide distribution of days to recommendation, with the higher margin falling between 750 and 1250 days. Two expections were Germany - with a relatively very small distrubtion for most of its recommendations - and Poland - with a relatively larger spread. 


## Country comparison by median

```{r}

df_selected <- df %>% 
  select(ID, Kraj, dni_do_rekomendacji) 

recommendation_order <- df_selected %>% 
  group_by(ID) %>% 
  arrange(ID, dni_do_rekomendacji) %>% 
  mutate(recommendation_order = row_number()) %>% 
  ungroup()


```

Analiza ogólna, bez uwzględnienia liczby rekomendacji w ramach danego wskazania.

```{r}

recommendation_order %>% 
  group_by(Kraj) %>% 
  summarise(
    order_median = median(recommendation_order)
  ) %>% 
  arrange(order_median) %>% 
  html_table()



```
 
 
 
```{r}

# Extract number of recommendations per ID 
wskazanie_count <- df_selected %>% 
  count(ID)

# Obtain recommendation order based on country and available number of recommendations 
recommendation_order2 <- df_selected %>% 
  left_join(wskazanie_count) %>% 
  group_by(ID) %>% 
  arrange(ID, dni_do_rekomendacji) %>% 
  mutate(recommendation_order = row_number()) %>% 
  ungroup() %>% 
  group_by(Kraj, n) %>% 
  summarise(
    order_median = median(recommendation_order)
  ) %>% 
  arrange(n, order_median) %>% 
  filter(n >= 6) 


recommendation_order2 %>% 
  html_table()



```
 
 
## Mean and variance of number of days by country, recommendation and therapeutic area


```{r}
df %>% 
  ggplot(aes(Kraj, dni_do_rekomendacji, fill = Rekomendacja)) +
  geom_boxplot() +
  coord_flip()
```


```{r}
df %>% 
  group_by(Kraj, Rekomendacja) %>% 
  summarise(
    mean = mean(dni_do_rekomendacji)
  ) %>% 
  drop_na() %>% 
  ggplot(aes(Kraj, mean, fill = Rekomendacja)) +
  geom_bar(stat = "identity", position = position_dodge()) +
  coord_flip()

```




```{r}

df %>% 
  ggplot(aes(Therapeutic_lumped, dni_do_rekomendacji)) +
  geom_boxplot()

```



```{r}
df %>% 
  ggplot(aes(Rekomendacja, dni_do_rekomendacji)) +
  geom_boxplot()

```



```{r}

df %>% 
  ggplot(aes(Therapeutic_lumped, dni_do_rekomendacji, fill = Rekomendacja)) +
  geom_boxplot()


```


```{r}
df %>% 
  ggplot(aes(Therapeutic_lumped, dni_do_rekomendacji)) +
  geom_boxplot() +
  facet_wrap(~Kraj)

```
The boxplots reveal an interaction effect between country's agency and therapeutic area. 
In other words, the effect of therapetuic area on the number of days differ from country to country with some countries displaying moore or less uniform prioritazation regardless of the area (e.g. Germany and Wales), while some countries seem to give a higher priority to specific areas (e.g. Poland, Australia, or Canada).


```{r}

df %>% 
  group_by(Therapeutic_lumped, Kraj) %>% 
  get_summary_stats(dni_do_rekomendacji)

```





# Model selection



```{r}
# Add an interaction effect as a possible weight
df <- df %>% 
  mutate(kraj_therap = interaction(Therapeutic_lumped, Kraj))



```




## Null model vs Only random effects model




```{r}






```




```{r}

glm_null <- glm(dni_do_rekomendacji ~ 1, data = df)
random_null <- lmer(dni_do_rekomendacji ~ 1 + (1|ID), data = df)
random_null2 <- lmer(dni_do_rekomendacji ~ 1 + (1|Year), data = df)
random_null3 <- lmer(dni_do_rekomendacji ~ Year + (1 + Year|ID), data = df)


null_models <- tibble(
  type = c("glm", "ID as random effects", "Year as random effects", "Year and ID as random effects"),
  model = list(glm_null, random_null, random_null2, random_null3)
)


null_models %>% 
  mutate(
    AIC = map_dbl(model, AIC)
  ) %>% 
  arrange(AIC)



```


Comparing the null linear model and null mixed effects models with varied random effects, the model with indication as random effects provides the best solution. Therefore, there is a statistical rationale to apply indication as the random effect.






## Mixed effects model - log transformed


```{r}
# Extract function for repeated modelling with updated data
model_mixed <- function(data) {
  fit <- lmer(log_days ~ Kraj + Therapeutic_lumped + Rekomendacja + (1|ID), data = data)
  
  return(fit)
}

# Import functions for performance measures
source("Funkcje/performance functions.R")


```



```{r}

# Exclude indications with only one observation
df_IDreduced <- df %>% 
  filter(!ID %in% ID_single)

# Create a list with all datasets
dataframes <- list(df, df_IDreduced)

# Set up a tibble with all datasets' versions
datasets <- tibble(
  data = dataframes,
  minimum_obs = 1:2
  )


# Obtain models
preliminary_mods <- datasets %>% 
  mutate(
    model = map(data, model_mixed),
    model_lm = map(data, lm, formula = log_days ~ Kraj + Therapeutic_lumped + Rekomendacja),
    aic_full = map_dbl(model, AIC),
    aic_lm = map_dbl(model_lm, AIC),
    summary_full = map(model, summary)
  )



preliminary_mods %>% 
  select(minimum_obs, aic_full, aic_lm) %>% 
  mutate(mixed_better = aic_full < aic_lm)

```

For both dataset versions the mixed effects model results in a better fit.


```{r}
preliminary_mods <- preliminary_mods %>% 
  select(-ends_with("lm"))

```




### Model diagnostics



```{r}

# Extract functions for quick assumptions check
hist_resid <- function(model) {
  p <- ggplot(mapping = aes(residuals(model))) +
    geom_histogram()
  return(p)
}

homoscedasticity_plot <- function(model) {
  
  p <- ggplot(mapping = aes(predict(model), residuals(model))) +
    geom_point() +
    geom_smooth(se = F)
  
  return(p)
}




```




```{r}
preliminary_mods <- preliminary_mods %>% 
  mutate(
    norm_full = map(model, hist_resid),
    homo_full = map(model, homoscedasticity_plot),
    VIF_full = map(model, car::vif)
  )
```



```{r}
cowplot::plot_grid(plotlist = preliminary_mods$norm_full )
```


The distributions of the fits to full and reduced datasets do not differ in a substantial way.


```{r}
cowplot::plot_grid(plotlist = preliminary_mods$homo_full, nrow = 2 )

```

Both models display a similar level of heteroscedasticity. 


```{r}

preliminary_mods$VIF_full


```



### Correcting models for heteroscedasticity and lack of normality 



```{r}

# Extract function for reducing 
filter_residuals <- function(data, model, cutoff = 3) {
  
  data %>% 
    mutate(resid = residuals(model) %>% scale() %>% as.double()) %>% 
    filter(abs(resid) <= cutoff)
} 




preliminary_mods <- preliminary_mods %>% 
  mutate(
    data_reduced = map2(data, model, filter_residuals),
    model_reduced = map(data_reduced, model_mixed),
    aic_reduced = map_dbl(model_reduced, AIC),
    r2_marg_reduced = map_dbl(model_reduced, r2_marginal)
  ) 
  

```




```{r}

# Add histograms and scatterplots
preliminary_mods <- preliminary_mods %>% 
  mutate(
    norm_reduced = map(model_reduced, hist_resid),
    homo_reduced = map(model_reduced, homoscedasticity_plot)
  )


# Function for adding ggplot title
add_title <- function(p, title) {
  
  force(title)
  
  p <- p +
    labs(title = title)
  
  
  return(p)
}


preliminary_plots <- preliminary_mods %>% 
  select(minimum_obs, matches("norm|homo|aic")) %>% 
  pivot_longer(-1, names_to = c(".value", "data"), names_pattern = "(.*)_(.*)") %>% 
  mutate(
    title = str_c("Data ", data, "; Min obs = ", minimum_obs, "; AIC = ", aic),
    norm = map2(norm, title, add_title ),
    homo = map2(homo, title, add_title )
  )

```

Check normality


```{r}
cowplot::plot_grid(plotlist = preliminary_plots$norm)

```


```{r}

cowplot::plot_grid(plotlist = preliminary_plots$homo)

```
Filtering the models by outliers above the absolute value of 3 of the standardized residual resulted in an improvement of heteroscedasticity.




```{r}
cowplot::plot_grid(plotlist = preliminary_plots$norm, nrow = 2)
```


Both reduced models display a normal distribution of the residuals.


```{r}

cowplot::plot_grid(plotlist = preliminary_plots$homo, nrow = 2)

```

However, both continue to have a substantial heteroscedasticity. 




#### Applying varIdent weigths


Dodać tutaj jeszcze jedną kombinację - z i bez efektu interakcji


```{r}
library(nlme)

# Create a vector with variables for calculating weights
weights_vars <- str_c("~ 1 | ", c("Kraj", "Therapeutic_lumped", "Rekomendacja")) 

# Create a vector with fixed effects formulas for different transformations of DVs
# fixed_formulas <- str_c(c("log_days", "dni_do_rekomendacji"), " ~ Kraj + Therapeutic_lumped + Rekomendacja + # Therapeutic_lumped:Kraj") 

# Create a tibble with all combinations of dataframes, methods, weights and DV transformations
weighted_mods <- expand_grid(
  DV = c("log_days", "dni_do_rekomendacji"),
  data = dataframes,
  method = c("ML", "REML"),
  weight_var = c(
    "Kraj", "Therapeutic_lumped", "Rekomendacja"
    )
) %>% 
  mutate(
    across(where(is.factor), ~as.character(.)),
    observations = map_dbl(data, nrow),
    min_obs = if_else(observations == 1933, 1, 2),
    mod_details = str_c(
      "DV = ", DV, 
      "; weights = ", weight_var, 
      "; min obs per indication = ", min_obs,
      "; method = ", method
      ), # Vector for plot titles
    fixed = str_c(DV, " ~ Kraj + Therapeutic_lumped + Rekomendacja ") %>% map(as.formula),
    weights = str_c("~ 1 | ", weight_var) %>% map(as.formula)
  )

# + Therapeutic_lumped:Kraj

```


```{r}
# Extract an lme function for iteration
lme_iterate <- function(fixed, data, method, weights) {
        lme(
          fixed = fixed,
          method = method,
          weights = varIdent(form =  weights),
          data = data, 
          random = ~ 1 + Year | ID
        
        )
      }


# Fit all model combinations
weighted_mods2 <- weighted_mods %>% 
  mutate(
    mod = pmap(
      list(fixed, data, method, weights),
      possibly(lme_iterate, quiet = TRUE, otherwise = NA)
    )
  ) 

# Remove unfitted models
weighted_mods2 <- weighted_mods2 %>% 
  filter(!map_lgl(mod, ~is.logical(.))) %>% 
  as_tibble()
  

# Obtain model performance AIC statistic
weighted_mods2 <- weighted_mods2 %>% 
  mutate(
    aic = map_dbl(mod, possibly(AIC, otherwise = Inf)),
    r2_marg = map_dbl(mod, possibly(r2_marginal, otherwise = Inf)),
    r2_cond = map_dbl(mod, possibly(r2_conditional, otherwise = Inf))
    ) %>% 
  mutate(across(c(aic, r2_marg, r2_cond), ~round(., 3))) %>% 
  arrange(desc(r2_marg))
```


```{r}
# Produce the table
weighted_mods2 %>% 
  select(mod_details, aic, r2_marg, r2_cond) %>% 
  datatable()

```

Among the models with logarithmically transformed dependent variable, the model with countries as weight and the full dataset (that is, considering all indications, even those, which have only one observation), resulted in the best fit.

Among the models which assumed an untrasformed dependent variable, the best fit 
The best model among those where the dependent variable remained untransformed also had weights as countries, but 



```{r}

# Compare models in terms of the heteroscedasticity degree
weighted_mods2 <- weighted_mods2 %>% 
  filter(aic != Inf) %>% 
  mutate(
    homo = map(mod, homoscedasticity_plot)
  ) 


weighted_mods2$homo


```


None of the weighted models was corrected for heteroscedasticity. 
Moreover, models with untransformed number of days seem to exhibit a non-linear relationship.



```{r}

weighted_best <- weighted_mods2 %>% 
  arrange(desc(r2_marg)) %>% 
  slice(1:6) %>% 
  mutate(
    data_filtered = map2(data, mod, filter_residuals),
    mod_filtered = pmap(
      list(fixed, data_filtered, method, weights),
      possibly(lme_iterate, quiet = TRUE, otherwise = NA)
    )
  )



weighted_best <- weighted_best %>% 
  mutate(
    homo_filtered = map(mod_filtered, homoscedasticity_plot),
    homo_filtered = map2(homo_filtered, mod_details, add_title),
    norm_filtered = map(mod_filtered, hist_resid),
    norm_filtered = map2(norm_filtered, mod_details, add_title),
  )

cowplot::plot_grid(plotlist =  weighted_best$homo_filtered)


```

Even after removing the outliers all models continue to display substantial heteroscedasticity.



```{r}
cowplot::plot_grid(plotlist =  weighted_best$norm_filtered)
```



#### Applying power and exponential var weights



```{r}
# Extract an lme function for iteration
lme_iterate2 <- function(data, method, type, value) {
        
  # Choose weighting function
  if (type == "power") {
    var_obtain <- match.fun("varPower")
  } else {var_obtain <- match.fun("varExp")}
  
  # Fit the model
  lme(
    fixed = log_days ~ Kraj + Therapeutic_lumped + Rekomendacja,
    method = method,
    weights = var_obtain(value = value, form =  ~fitted(.)),
    data = data, 
    random = ~ 1 | ID
    )
  
  }

# Create a tibble with all combinations of dataframes, methods, weights and DV transformations
weighted_fitted <- expand_grid(
  data = dataframes,
  method = c("ML", "REML"),
  type = c("power", "exp"),
  value = seq(-1, 0, 0.2)
) %>% 
  mutate(
    across(where(is.factor), ~as.character(.)),
    observations = map_dbl(data, nrow),
    min_obs = if_else(observations == 1933, 1, 2),
    mod_details = str_c(
      "weights = ", type, " to ", value,
      "; min obs per indication = ", min_obs,
      "; method = ", method
      ), # Vector for plot titles
    )




# Fit all model combinations
weighted_fitted <- weighted_fitted %>% 
  mutate(
    mod = pmap(
      list(data, method, type, value),
      possibly(lme_iterate2, quiet = TRUE, otherwise = NA)
    )
  )
```


```{r}
# Remove unfitted models
 weighted_fitted2 <-  weighted_fitted %>% 
  filter(!map_lgl(mod, ~is.logical(.))) %>% 
  as_tibble()
  

# Obtain model performance AIC statistic
weighted_fitted2 <-  weighted_fitted2 %>% 
  mutate(
    aic = map_dbl(mod, possibly(AIC, otherwise = Inf)),
    r2_marg = map_dbl(mod, possibly(r2_marginal, otherwise = Inf)),
    r2_cond = map_dbl(mod, possibly(r2_conditional, otherwise = Inf))
    ) %>% 
  mutate(across(c(aic, r2_marg, r2_cond), ~round(., 3))) %>% 
  arrange(aic)



weighted_fitted2 %>% 
  select(mod_details, aic, r2_marg, r2_cond) %>% 
  datatable()

```
Applying power and fitted 


```{r}
# Compare models in terms of the heteroscedasticity degree
weighted_fitted2 <- weighted_fitted2 %>% 
  filter(aic != Inf) %>% 
  mutate(
    homo = map(mod, homoscedasticity_plot)
  ) 


weighted_fitted2$homo



```




#### Other solutions

-   bootstrap for the estimated marginal means
    -   https://stackoverflow.com/questions/75852979/bootstrapping-emmeans-derived-from-a-multilevel-regression-but-error-in-t-star
    -   https://stackoverflow.com/questions/39358438/r-obtain-coefficientsci-from-bootstrapping-mixed-effect-model-results
-   robust errors


**Dodać analizę symulacyjną z efektem interakcji**


# Final model analysis



 
 
## Fit the model


```{r}

best_model <- weighted_best %>% 
  arrange(desc(r2_marg)) %>% 
  slice(1) 


best_model$mod_filtered

mixed_best <- lme(
  fixed = dni_do_rekomendacji ~ Kraj + Therapeutic_lumped + Rekomendacja, 
  random = ~1 + Year | ID,
  weights =  varIdent(form = ~1 | Kraj),
  data = best_model$data_filtered[[1]]
    
  
) 



```




```{r}
# confint(mixed_best)
intervals(mixed_best)

```

Delta method for obtaining se back to normal after log transformation
https://stats.oarc.ucla.edu/r/faq/how-can-i-estimate-the-standard-error-of-transformed-regression-parameters-in-r-using-the-delta-method/


## Country comparison post-hoc analysis


```{r}

library(emmeans)

# Obliczam różnice dla wszystkich par krajów
emm <- emmeans(mixed_best, pairwise ~ Kraj, type = "response")





# Wyodrębniam tabelę ze średnimi dla krajów
country_means <- emm$emmeans %>% 
  as_tibble()


# Sprowadzam do macierzy ala interkorelacje
posthoc1 <- emm$contrasts %>% 
  as_tibble() %>% 
  separate(contrast, into = c("Country1", "Country2"), sep = " / ") 

posthoc2 <- posthoc1 %>% 
  rename(
    Country1 = Country2,
    Country2 = Country1
    ) 


posthoc1 %>% 
  add_row(posthoc2) %>% 
  mutate(
    across(c(Country1, Country2), ~factor(., levels = Kraj_lvls))
        ) %>% 
  mutate(sig = case_when(
    p.value > 0.05 ~ "",
    p.value <= 0.05 & p.value > 0.01 ~ "*",
    p.value <= 0.01 & p.value > 0.001 ~ "**",
    p.value <= 0.001 ~ "***"
  )) %>% 
  mutate(
    across(where(is.double), ~round(., 2))
  ) %>% 
  mutate(
    est = str_c(ratio, " (", SE, ")", sig)
  ) %>% 
  select(Country1, Country2, est) %>% 
  pivot_wider(names_from = Country2, values_from = est, names_sort = T)
```


Wykres dla estimated marginal means


```{r}

country_means %>% 
  as_tibble() %>% 
  ggplot(aes(fct_reorder(Kraj, response), response, group = 1))  +
  geom_line() +
  geom_errorbar(aes(ymin = lower.CL, ymax = upper.CL)) +
  geom_point()

```




# Description and Interpretation

-   Extreme values were removed to allow for a normal distribution of the errors
-   Weights were applied based on country
-   logarithmic transformation


